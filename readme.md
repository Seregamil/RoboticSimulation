# Robotics/IOT .NET Core

## Дисклеймер

___
## Используемые библиотеки и приложения

| Наименование | Применение |
|--|--|
| **Библиотеки** |
|[MessagePack](https://msgpack.org/) | Используется для сериализации/десериализации сообщений между клиентом и роботом |  
|[Serilog](https://serilog.net/) | Используется для логирования информации и сохранения ее в базу данных |    
|[LiteDB](https://www.litedb.org/) | NoSQL-хранилище для хранения логов |  
|[System.Device.GPIO](https://learn.microsoft.com/ru-ru/dotnet/iot/) | Библиотека для работы с IOT |  
|[NetMQ](https://netmq.readthedocs.io/en/latest/) | Библиотека для работы с библиотекой [ZeroMQ](https://zeromq.org/). Используется для TCP-сокетов |  
|[nanoFramework](https://www.nanoframework.net/) | Библиотека для написания кода на C# для IOT |  
| **Приложения** |
| [LiteDB.Studio](https://github.com/mbdavid/LiteDB.Studio) | Приложение для просмотра и редактирования LiteDB |

___
## Общая схема работы проекта

![scheme](./images/scheme.png)

0. *Робот* подключается к WiFi и получает сетевые настройки.
1. Пользователь *Master* подключается к WiFi сетевые настройки.  
2. Пользователь *Master* запускает приложение для установления сетевого соединения с роботом. В приложении:  
    2.1 Производится станирование сети  
    2.2 В случае успешного нахождения устройства, производится подключение к нему  
3. После успешного установления сетевого соединения идет обмен данными в режиме реального времени и логирование данных в [*черный ящик*](https://ru.wikipedia.org/wiki/%D0%91%D0%BE%D1%80%D1%82%D0%BE%D0%B2%D0%BE%D0%B9_%D1%81%D0%B0%D0%BC%D0%BE%D0%BF%D0%B8%D1%81%D0%B5%D1%86)

### Хранение данных 
В качестве системы хранения данных (логирование), используется NoSQL-хранилище (*[LiteDB](https://www.litedb.org/)*)  

Суммарно, хранится **три сессии** данных, остальные удаляются ввиду отсутствия какой-либо необходимости и с целью сохранить память на MicroSD.  
___
## Схема взаимодействия 
![communication](./images/communication.png)

Передача и получение трафика производятся с использованием [ZeroMQ](https://zeromq.org/) с использованием **Pair Socket**   
> В предыдущей версии использовался принцип *Pull/Push*, где в роли получающего был непосредственно робот, но, ввиду того, что я решил направлять данные в обе стороны, было принято отказаться от данного подхода  

___
## Протокол обмена данными

Обмен данными между клиентом и сервером осуществляется посредством передачи `IEnumerable<byte>` друг с другом по следующей схеме, реализованной в файле [MessagesExtension.cs](./Platform/Extensions/MessagesExtension.cs):  
```csharp
var bytesList = new List<byte[]>
{
    identifyModel.Serialize(), // RoboIdentifier or ClientIdentifier
    Array.Empty<byte>(), // Always empty array
    new [] { (byte) type }, // Always MessageType casted to byte
    Array.Empty<byte>(), // Always empty array
    MessagePackSerializer.Serialize(model) // Workload model
    // ... another serialization of workload
};
```

Основной алгоритм обработки полученных сообщений выглядит следующим образом:
> 1. Производится попытка получить сообщение из потока
> 2. Производится сверка количества полученных "кадров" в рамках одного сообщения
>> 2.1. Если количество кадров меньше 3, это считается неполным сообщением, будет сообщение об ошибке.  
>> 2.2. Если кадр с первым индексом будет чем-то заполнен, это считается нарушением протокола. Будет сообщение об ошибке.  
>> 2.3. Если десериализованная модель клиента или десериализованный тип будут иметь значение null, это считается нарушением целостности данных, будет выведена ошибка.  
> 3. Производится сверка количества кадров, если их количество менее трех и менее пяти, обработка кадров будет считаться оконченной.  
> 4. Если количество символов в четвертом кадре будет более нуля, это считается нарушением протокола, будет сообщение об ошибке.  
> 5. Все дальнейшие кадры будут в цикле десериализованны, согласно полученному MessageType из второго кадра и будут произведены действия, которые соответствуют модели данных.  
